# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2014 Violin Memory, Inc.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

"""
Violin Memory Fibrechannel (FCP) Driver for Openstack Cinder

Uses Violin REST API via XG-Tools to manage a standard V6000 series
flash array to provide network block-storage services.

by Ryan Lucio
Senior Software Engineer
Violin Memory

Driver support (verified for G6.3.0):
-------------------------------------
Driver Setup:                   YES
Volume Create/Delete:           YES
Export Create/Remove:           YES
Volume Attach/Detach:           YES
Snapshot Create/Delete:         YES
Create Volume from Snapshot:    YES
Clone Volume:                   YES
Get Volume Stats:               YES
Volume Extend:                  YES
Volume Migrate:                 NO*
Copy Image to Volume:           YES*
Copy Volume to Image:           YES*

* functionality inherited from base class driver
"""

from cinder.db.sqlalchemy import models
from cinder import exception
from cinder.openstack.common import log as logging
from cinder import utils
from cinder.volume.drivers.violin import v6000_common

LOG = logging.getLogger(__name__)

try:
    from . import version
    __version__ = version.__version__
except Exception:
    # version.py is autogenerated during packaging. If we are running
    # against original source it will not be present.
    __version__ = "unknown"


class V6000FCDriver(v6000_common.V6000CommonDriver):
    """Executes commands relating to Violin Memory Arrays."""

    def __init__(self, *args, **kwargs):
        super(V6000FCDriver, self).__init__(*args, **kwargs)
        self.gateway_fc_wwns = []
        LOG.info(_("Initialized driver %(name)s version: %(vers)s") %
                 {'name': self.__class__.__name__, 'vers': __version__})

    def do_setup(self, context):
        """Any initialization the driver does while starting."""
        super(V6000FCDriver, self).do_setup(context)
        self.gateway_fc_wwns = self._get_active_fc_targets()

    def check_for_setup_error(self):
        """Returns an error if prerequisites aren't met."""
        super(V6000FCDriver, self).check_for_setup_error()
        if len(self.gateway_fc_wwns) == 0:
            raise v6000_common.InvalidBackendConfig(
                reason=_('No FCP targets found'))

    def ensure_export(self, context, volume):
        """Synchronously checks and re-exports volumes at cinder start time."""
        pass

    def create_export(self, context, volume):
        """Exports the volume."""
        pass

    def remove_export(self, context, volume):
        """Removes an export for a logical volume."""
        pass

    def initialize_connection(self, volume, connector):
        """Initializes the connection (target<-->initiator)."""
        igroup = None

        if self.config.use_igroups:
            #
            # Most drivers don't use igroups, because there are a
            # number of issues with multipathing and iscsi/fcp where
            # lun devices either aren't cleaned up properly or are
            # stale (from previous scans).
            #
            # If the customer really wants igroups for whatever
            # reason, we create a new igroup for each host/hypervisor.
            # Every lun that is exported to the particular
            # hypervisor/host will be contained in this igroup.  This
            # should prevent other hosts from seeing luns they aren't
            # using when they perform scans.
            #
            igroup = self._get_igroup(volume, connector)
            self._add_igroup_member(connector, igroup)

        if isinstance(volume, models.Volume):
            lun_id = self._export_lun(volume, connector, igroup)
        else:
            lun_id = self._export_snapshot(volume, connector, igroup)

        self.vmem_vip.basic.save_config()

        properties = {}
        properties['target_discovered'] = True
        properties['target_wwn'] = self.gateway_fc_wwns
        properties['target_lun'] = lun_id
        properties['access_mode'] = 'rw'

        return {'driver_volume_type': 'fibre_channel', 'data': properties}

    def terminate_connection(self, volume, connector, force=False, **kwargs):
        """Terminates the connection (target<-->initiator)."""
        if isinstance(volume, models.Volume):
            self._unexport_lun(volume)
        else:
            self._unexport_snapshot(volume)

        self.vmem_vip.basic.save_config()

    def get_volume_stats(self, refresh=False):
        """Get volume stats."""
        if refresh or not self.stats:
            self._update_stats()
        return self.stats

    @utils.synchronized('vmem-export')
    def _export_lun(self, volume, connector=None, igroup=None):
        """Generates the export configuration for the given volume.

        The equivalent CLI command is "lun export container
        <container_name> name <lun_name>"

        Arguments:
            volume -- volume object provided by the Manager
            connector -- connector object provided by the Manager
            igroup -- name of igroup to use for exporting

        Returns:
            lun_id -- the LUN ID assigned by the backend
        """
        lun_id = ''
        export_to = ''
        v = self.vmem_vip

        lun_id = self.lun_tracker.get_lun_id_for_volume(volume)

        if igroup:
            export_to = igroup
        elif connector:
            export_to = self._convert_wwns_openstack_to_vmem(
                connector['wwpns'])
        else:
            raise exception.Error(_("No initiators found, cannot proceed"))

        LOG.info(_("Exporting lun %(vol_id)s on lun_id %(lun_id)s") %
                 {'vol_id': volume['id'], 'lun_id': lun_id})

        try:
            self._send_cmd_and_verify(v.lun.export_lun,
                                      self._wait_for_exportstate,
                                      '',
                                      [self.container, volume['id'],
                                       'all', export_to, lun_id],
                                      [volume['id'], True])

        except Exception:
            LOG.exception(_("LUN export failed!"))
            raise

        return lun_id

    @utils.synchronized('vmem-export')
    def _unexport_lun(self, volume):
        """Removes the export configuration for the given volume.

        The equivalent CLI command is "no lun export container
        <container_name> name <lun_name>"

        Arguments:
            volume -- volume object provided by the Manager
        """
        v = self.vmem_vip

        LOG.info(_("Unexporting lun %s"), volume['id'])

        try:
            self._send_cmd_and_verify(v.lun.unexport_lun,
                                      self._wait_for_exportstate,
                                      '',
                                      [self.container, volume['id'],
                                       'all', 'all', 'auto'],
                                      [volume['id'], False])

        except v6000_common.ViolinBackendErrNotFound:
            LOG.info(_("Lun %s already unexported, continuing"),
                     volume['id'])

        except Exception:
            LOG.exception(_("LUN unexport failed!"))
            raise

    @utils.synchronized('vmem-export')
    def _export_snapshot(self, snapshot, connector=None, igroup=None):
        """Generates the export configuration for the given snapshot.

        The equivalent CLI command is "snapshot export container
        PROD08 lun <snapshot_name> name <volume_name>"

        Arguments:
            snapshot -- snapshot object provided by the Manager
            connector -- connector object provided by the Manager
            igroup -- name of igroup to use for exporting

        Returns:
            lun_id -- the LUN ID assigned by the backend
        """
        lun_id = ''
        export_to = ''
        v = self.vmem_vip

        lun_id = self.lun_tracker.get_lun_id_for_snapshot(snapshot)

        if igroup:
            export_to = igroup
        elif connector:
            export_to = self._convert_wwns_openstack_to_vmem(
                connector['wwpns'])
        else:
            raise exception.Error(_("No initiators found, cannot proceed"))

        LOG.info(_("Exporting snapshot %s"), snapshot['id'])

        try:
            self._send_cmd(v.snapshot.export_lun_snapshot, '',
                           self.container, snapshot['volume_id'],
                           snapshot['id'], export_to, 'all', lun_id)

        except Exception:
            LOG.exception(_("Snapshot export failed!"))
            raise

        else:
            self._wait_for_exportstate(snapshot['id'], True)

        return lun_id

    @utils.synchronized('vmem-export')
    def _unexport_snapshot(self, snapshot):
        """Removes the export configuration for the given snapshot.

        The equivalent CLI command is "no snapshot export container
        PROD08 lun <snapshot_name> name <volume_name>"

        Arguments:
            snapshot -- snapshot object provided by the Manager
        """
        v = self.vmem_vip

        LOG.info(_("Unexporting snapshot %s"), snapshot['id'])

        try:
            self._send_cmd(v.snapshot.unexport_lun_snapshot, '',
                           self.container, snapshot['volume_id'],
                           snapshot['id'], 'all', 'all', 'auto', False)

        except Exception:
            LOG.exception(_("Snapshot export failed!"))
            raise

        else:
            self._wait_for_exportstate(snapshot['id'], False)

    def _add_igroup_member(self, connector, igroup):
        """Add an initiator to the openstack igroup so it can see exports.

        The equivalent CLI command is "igroup addto name <igroup_name>
        initiators <initiator_name>"

        Arguments:
            connector -- connector object provided by the Manager
        """
        v = self.vmem_vip
        wwpns = self._convert_wwns_openstack_to_vmem(connector['wwpns'])

        LOG.info(_("Adding initiators %(wwpns)s to igroup %(igroup)s") %
                 {'wwpns': wwpns, 'igroup': igroup})

        resp = v.igroup.add_initiators(igroup, wwpns)

        if resp['code'] != 0:
            raise exception.Error(
                _('Failed to add igroup member: %(code)d, %(message)s') % resp)

    def _update_stats(self):
        """Gathers array stats from the backend and converts them to GB values.
        """
        data = {}
        total_gb = 'unknown'
        free_gb = 'unknown'
        v = self.vmem_vip

        master_cluster_id = self.vmem_vip.basic.get_node_values(
            '/cluster/state/master_id').values()[0]

        bn1 = "/vshare/state/global/%s/container/%s/total_bytes" \
            % (master_cluster_id, self.container)
        bn2 = "/vshare/state/global/%s/container/%s/free_bytes" \
            % (master_cluster_id, self.container)
        resp = v.basic.get_node_values([bn1, bn2])

        if bn1 in resp:
            total_gb = resp[bn1] / 1024 / 1024 / 1024
        else:
            LOG.warn(_("Failed to receive update for total_gb stat!"))

        if bn2 in resp:
            free_gb = resp[bn2] / 1024 / 1024 / 1024
        else:
            LOG.warn(_("Failed to receive update for free_gb stat!"))

        backend_name = self.config.volume_backend_name
        data['volume_backend_name'] = backend_name or self.__class__.__name__
        data['vendor_name'] = 'Violin Memory, Inc.'
        data['driver_version'] = __version__
        data['storage_protocol'] = 'fibre_channel'
        data['reserved_percentage'] = 0
        data['QoS_support'] = False
        data['total_capacity_gb'] = total_gb
        data['free_capacity_gb'] = free_gb

        for i in data:
            LOG.debug(_("stat update: %(name)s=%(data)s") %
                      {'name': i, 'data': data[i]})

        self.stats = data

    def _get_active_fc_targets(self):
        """Get a list of gateway WWNs that can be used as FCP targets.

        Arguments:
            mg_conn -- active XG connection to one of the gateways

        Returns:
            active_gw_fcp_wwns -- list of WWNs
        """
        v = self.vmem_vip.basic
        active_gw_fcp_wwns = []

        gateway_ids = v.get_node_values('/vshare/state/global/*').values()

        for i in gateway_ids:
            bn = "/vshare/state/global/%d/target/fc/**" % i
            resp = v.get_node_values(bn)

            for node in resp:
                if node.endswith('/wwn'):
                    active_gw_fcp_wwns.append(resp[node])

        return self._convert_wwns_vmem_to_openstack(active_gw_fcp_wwns)

    def _convert_wwns_openstack_to_vmem(self, wwns):
        """Convert a list of Openstack WWNs to VMEM compatible WWN
        strings.

        Arguments:
            wwns -- list of Openstack-based WWN strings.

        Returns:
            output -- list of VMEM-based WWN strings.
        """
        # input format is '50014380186b3f65', output format is
        # 'wwn.50:01:43:80:18:6b:3f:65'
        #
        output = []
        for w in wwns:
            output.append('wwn.{0}'.format(
                ':'.join(w[x:x + 2] for x in xrange(0, len(w), 2))))
        return output

    def _convert_wwns_vmem_to_openstack(self, wwns):
        """Convert a list of VMEM WWNs to Openstack compatible WWN
        strings.

        Arguments:
            wwns -- list of VMEM-based WWN strings.

        Returns:
            output -- list of Openstack-based WWN strings.
        """
        # input format is 'wwn.50:01:43:80:18:6b:3f:65', output format
        # is '50014380186b3f65'
        #
        output = []
        for w in wwns:
            output.append(''.join(w[4:].split(':')))
        return output
