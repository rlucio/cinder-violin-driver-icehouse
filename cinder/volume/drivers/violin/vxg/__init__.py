#!/usr/bin/env python

# vim: tabstop=4 shiftwidth=4 softtabstop=4

# Copyright 2013 Violin Memory, Inc.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

# Get our library version
try:
    import cinder.volume.drivers.violin.vxg.version
    __version__ = cinder.volume.drivers.violin.vxg.version.__version__
except Exception:
    # version.py is autogenerated during packaging. If we are running
    # against original source it will not be present.
    __version__ = "unknown"


import sys
import urllib2

# Require python 2.6.0
# Use hexversion for arithmatic comparison versus major-minor-micro tuple
if sys.hexversion <= 0x02060000:
    raise ImportError("Requires python 2.6.  Running python %d.%d.%d." %
                      (sys.version_info[0], sys.version_info[1],
                       sys.version_info[2]))

import inspect

from cinder.volume.drivers.violin.vxg.core.session import Vmos7JsonSession
from cinder.volume.drivers.violin.vxg.core.session import XGSession
from cinder.volume.drivers.violin.vxg.varray import varray
from cinder.volume.drivers.violin.vxg.vmos7 import vmos7
from cinder.volume.drivers.violin.vxg.vshare import vshare


def open(host, user='admin', password='', proto='https',
         version=1, debug=False, http_fallback=True,
         keepalive=False, logger=None):
    """Opens up a REST connection with the given Violin appliance.

    This will first login to the given host, then access that host's version
    node registration.  Depending on what the host identifies itself as, an
    object compatible with that particular version will be returned.

    If there are any problems (such as auth failure or inaccessible hostname),
    then None will be returned.

    Arguments:
        host          -- Name or IP address of the host to connect to
        user          -- Username to login with
        password      -- Password for the user
        proto         -- Either 'http' or 'https'
        version       -- Reserved for future use
        debug         -- Enable/disable debugging to stdout (bool)
        http_fallback -- If proto is https and https fails, fallback to http
        keepalive     -- Attempt to reconnect on session loss
        logger        -- Where to send logs (default: sys.stdout)

    Returns:
        An authenticated REST connection to the appliance.  If there are any
        connection problems, then None is returned.

    """
    # Build up protocols to attempt
    protocols_to_try = []
    if proto.lower() == 'https':
        protocols_to_try.append('https')
    if proto.lower() == 'http' or http_fallback:
        protocols_to_try.append('http')

    # Verify the logger
    log_fd = None
    if logger is None:
        log_fd = sys.stdout
    elif (hasattr(logger, 'write') and callable(logger.write) and
          hasattr(logger, 'flush') and callable(logger.flush)):
        log_fd = logger
    else:
        raise ValueError('logger needs callable "write" and "flush" methods')

    # Discover the Violin appliance supplied
    for current_protocol in protocols_to_try:
        try:
            stream = urllib2.urlopen('{0}://{1}'.format(
                                     current_protocol, host))
        except urllib2.URLError as e:
            if debug:
                log_fd.write('{0}: {1}'.format(current_protocol, e))
                log_fd.flush()
        else:
            try:
                html = stream.read()
            except Exception as e:
                if debug:
                    log_fd.write('{0} (read): {1}'.format(
                                 current_protocol, e))
                    log_fd.flush()
                try:
                    stream.close()
                except Exception:
                    pass
            else:
                opener = None
                if 'viewport' in html:
                    opener = _open_json_gateway
                elif 'template' in html:
                    opener = _open_xml_gateway
                elif 'Violin Concerto Console' in html:
                    opener = _open_vmos7_json_gateway
                stream.close()
                if opener:
                    try:
                        return opener(host, user, password, current_protocol,
                                      version, debug, keepalive, log_fd)
                    except IndexError as e:
                        log_fd.write('Failed to get authenticated session ' +
                                     'and/or retrieve the ' +
                                     'version ({0}): {1}'.format(
                                     e.__class__.__name__, e))
                        log_fd.flush()
                        return None

    # Nothing worked
    return None


def _get_session_and_version(cls_type, host, user, password, debug,
                             proto, keepalive, log_fd):
    """Internal function to get a session and its version.

    A tuple is returned from this fuction.

    """
    session = cls_type(host, user, password, debug, proto,
                       True, keepalive, log_fd)
    return (session, session._get_version_info())


def _open_vmos7_json_gateway(host, user, password, proto,
                             version, debug, keepalive, log_fd):
    """JSON REST connection for Violin vMOS7 device types.

    """
    session, version_info = _get_session_and_version(Vmos7JsonSession, host,
                                                     user, password, debug,
                                                     proto, keepalive, log_fd)

    return __getDeviceFor(version_info, session, vmos7, debug)


def _open_json_gateway(host, user, password, proto,
                       version, debug, keepalive, log_fd):
    """JSON REST connection for Symphony.

    """
    raise NotImplementedError('Violin Symphony devices are unsupported')


def _open_xml_gateway(host, user, password, proto,
                      version, debug, keepalive, log_fd):
    """Get the traditional tallmaple REST connection.

    """
    session, version_info = _get_session_and_version(XGSession, host, user,
                                                     password, debug, proto,
                                                     keepalive, log_fd)

    if version_info['type'] in ('A',):
        # ACM
        return __getDeviceFor(version_info, session, varray, debug)
    elif version_info['type'] in ('G', 'V'):
        # MG
        return __getDeviceFor(version_info, session, vshare, debug)

    msg = 'Unknown version host_type: {0}'
    raise Exception(msg.format(version_info['type']))


def __getDeviceFor(version_info, session, moduleToSearch, debug):
    """Returns a device object.

    If there's a problem, an Exception is raised.

    """
    version_as_tuple = __to_version_tuple(version_info['version'])
    supported_versions = {}

    for name, obj in inspect.getmembers(moduleToSearch):
        if (inspect.isclass(obj) and name.find(
                moduleToSearch.CLASS_NAMES) > -1):
            if isinstance(obj._versions, basestring):
                supported_versions[__to_version_tuple(obj._versions)] = obj
            elif isinstance(obj._versions, list):
                for x in obj._versions:
                    supported_versions[__to_version_tuple(x)] = obj
            else:
                raise Exception('Unknown version type' +
                                '%s ' % (obj.versions.__class__,) +
                                'encountered in ' +
                                'class %s.' % (name,))

    # Find the newest object for the discovered version
    for x in reversed(sorted(supported_versions.keys())):
        if version_as_tuple >= x:
            return supported_versions[x](session, version_info)
    else:
        session.close()
        raise Exception('No matching connection class for {0}'.format(
                        version_info))


def __to_version_tuple(version):
    """Turns a dotted version string into a tuple for comparison's sake.

    """
    return tuple(int(x) for x in version.split('.'))
